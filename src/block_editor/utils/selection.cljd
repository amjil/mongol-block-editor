(ns block-editor.utils.selection
  (:require
   ["package:flutter/material.dart" :as m]
   ["dart:async" :as async]
   [virtual-keyboard.keyboard-action :as action]
   [virtual-keyboard.input-control :as control]
   [clojure.set :as set]
   [block-editor.utils.block :as block]
   [block-editor.state :as state]))


(defn set-editing-value [controller new-text offset]
  (set! (.-value controller)
        (m/TextEditingValue.
         .text new-text
         .selection (m.TextSelection/collapsed .offset offset))))

(defn is-cursor-in-double-brackets [controller]
  (let [text (.-text controller)
        selection (.-selection controller)]
    (if (and (.-isValid selection) (.-isCollapsed selection))
      (let [cursor (.-start selection)
            open-index (.lastIndexOf text "[[" cursor)
            close-index (.indexOf text "]]" cursor)
            inside (and (not= -1 open-index)
                        (not= -1 close-index)
                        (< open-index cursor)
                        (<= cursor close-index))]
        [inside open-index close-index])
      [false -1 -1])))

(defn next-block []
  (let [editing-value @control/editing-value
        text (.-text editing-value)
        selection (.-selection editing-value)
        current-block-id (nth @state/ids @state/edit-index)]
    ;; Check if there is content after cursor
    (if (and (.-isValid selection) (.-isCollapsed selection))
      (let [cursor (.-start selection)
            text-length (count text)
            text-after-cursor (if (< cursor text-length)
                                (subs text cursor)
                                "")]
        (if (not-empty text-after-cursor)
          ;; Has content: copy text after cursor to new block, keep only text before cursor in current block
          (let [text-before-cursor (subs text 0 cursor)]
            ;; Update current block content
            (block/update-block-content current-block-id text-before-cursor)
            ;; Create new block
            (block/create-block)
            (let [idx (inc @state/edit-index)
                  new-block-id (get @state/ids idx)]
              ;; Set text after cursor to new block
              (block/update-block-content new-block-id text-after-cursor)
              (action/clear-candidates)
              (reset! state/edit-index idx)
              (reset! state/current-id new-block-id)
              (control/reset-text text-after-cursor)))
          ;; No content: create new block directly
          (do
            (block/create-block)
            (let [idx (inc @state/edit-index)
                  block-id (get @state/ids idx)
                  new-content (get @state/blocks block-id)]
              (action/clear-candidates)
              (reset! state/edit-index idx)
              (reset! state/current-id block-id)
              (control/reset-text new-content)))))
      ;; Invalid cursor: create new block directly
      (do
        (block/create-block)
        (let [idx (inc @state/edit-index)
              block-id (get @state/ids idx)
              new-content (get @state/blocks block-id)]
          (action/clear-candidates)
          (reset! state/edit-index idx)
          (reset! state/current-id block-id)
          (control/reset-text new-content))))))

(defn next-content []
  (let [editing-value @control/editing-value
        [inside _ _] (is-cursor-in-double-brackets editing-value)]
    (if (true? inside)
      (do
        (control/update-selection 2)
        (reset! state/open-search-box false))
      (next-block))))

(defn run-search-index [text open-index close-index]
  (reset! state/open-search-box true)
  (let [query (if (< (+ 2 open-index) close-index)
                (.substring text (+ 2 open-index) close-index)
                "")]
    (reset! state/search-query query)
    (state/set-search-results! [])
    (when (not-empty query)
      (when-let [handler @state/search-handler]
        (let [result (handler {:query query
                               :set-results state/set-search-results!})]
          (cond
            (nil? result) nil
            (instance? async/Future result) (.then result (fn [data]
                                                            (when-not (empty? data)
                                                              (let [data (map #(.-data %) data)]
                                                                (state/set-search-results! data)))))
            :else (state/set-search-results! result)))))))
         
(defn cursor-in-double-brackets [controller]
  (let [text (.-text controller)
        [inside open-index close-index] (is-cursor-in-double-brackets controller)]
    (if (true? inside)
      (run-search-index text open-index close-index)
      (do
        (reset! state/open-search-box false)
        (state/clear-search!)))))

(defn on-click-reorderable-item [controller idx]
  (let [block-id (nth @state/ids idx)
        new-content (get @state/blocks block-id)]
    (action/clear-candidates)
    (set-editing-value controller new-content (count new-content))
    (reset! state/edit-index idx)))

(defn on-update [controller idx text]
  (let [block-id (nth @state/ids idx)]
    (when (= idx @state/edit-index)
      (let [old-text (get @state/blocks block-id)
            old-titles (state/extract-link-titles old-text)
            new-titles (state/extract-link-titles text)
            removed-titles (set/difference old-titles new-titles)]
        ;; Remove link ids for links that were deleted from text
        (doseq [title removed-titles]
          (state/remove-link-id! title))
        (block/update-block-content block-id text))))
  (cursor-in-double-brackets controller))

(defn on-select-search-item [selected-title selected-id]
  (let [editing-value @control/editing-value
        text (.-text editing-value)
        selection (.-selection editing-value)]
    (if (and (.-isValid selection) (.-isCollapsed selection))
      (let [cursor (.-start selection)
            open-index (.lastIndexOf text "[[" cursor)
            close-index (.indexOf text "]]" cursor)]
        (if (and (not= -1 open-index)
                 (not= -1 close-index)
                 (< open-index cursor)
                 (<= cursor close-index))
          (let [;; Only save title, not id in text
                link-text selected-title
                ;; If id exists, save to mapping table
                _ (when (and selected-id (not-empty selected-id))
                    (state/set-link-id! selected-title selected-id))
                before (subs text 0 (+ open-index 2))
                after (subs text close-index)
                new-text (str before link-text after)
                block-id (nth @state/ids @state/edit-index)
                target-cursor (+ open-index 2 (count link-text) 2)]
            (control/reset-text new-text)
            (block/update-block-content block-id new-text)
            ;; Move cursor after selected-title, skip ]]
            (let [new-editing-value @control/editing-value
                  current-cursor (count (.-text new-editing-value))
                  offset (- target-cursor current-cursor)]
              (when (not= 0 offset)
                (control/update-selection offset)))
            (reset! state/open-search-box false)
            (state/clear-search!))
          (do
            (reset! state/open-search-box false)
            (state/clear-search!))))
      (do
        (reset! state/open-search-box false)
        (state/clear-search!)))))